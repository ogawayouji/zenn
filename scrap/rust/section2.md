# 第二章　基本制御フロー

## コメントアウト

「//」で行をコメントアウト可能

## if文

条件式は「（）」で囲む必要がない。

```rust
//　"199未満"が出力
let x = 198

if x < 100 {
	println!("{}未満", 199);
}
```

## loop文

無限ループする構文（初めてみた）

```rust
// xが常に増え続ける
loop {
	x += 1
}
```

while文などと同様、breakで抜け出すことができる。

## for文

for in で記述できる（Typescriptも似たような記述方法がある。すぐ慣れそう。）

```rust
for x in 0..5 {
	println!("{}", x)
}
```

0 .. 5 : 0から5の一個手前まで（つまり、**0から4まで**）のイテレータ

0 ..= 5：**0から5まで**のイテレータ

## match文

switch文の強化版みたいなもの？

**必ず条件を網羅しなければならない**という制約がある。

```rust
match x {
	0 => {
		// 0に該当するとき
	}
	1 | 2 | 3 => {
		// 1, 2, 3のいずれかに該当するとき
	}
	4..=10 => {
		// ４から10のいずれかに該当するとき
		// イテレータを使用可能
	}
	matched_num @ 10..=100 => {
		// 10から100のいずれかに該当するとき
		// 詳細は下部
	}
	_ => {
		// switch文のdefaultに該当する。「_」で表現。
	}
}
```

@：この記述の仕方で、イテレータに該当するときにmatched_numと言う名前の**変数に紐付け**できる。

## ブロック式

if文、match文、関数、ブロック（{}で囲んだ式のまとまり）は**単一の方法で値を返せる。**

それぞれの文で**文末記号（;）がないもの**が返される。

- ブロック式

```rust
let x = {
	let a = 2;
	let b = 3;
	a + b
}
```

- 関数

<aside>
💡 関数は 「return」 のようなものを使用せず、文末記号がない式が返り値になる。

</aside>

```rust
fn sample() -> i32 {
	let c = 42
	let d = 100
	// c + d、つまり142が返り値になる
	c + d
}
```

- if文

三項演算子などを返せる（文末記号はつけてはダメ）

- loop

（ブロック式とは異なるが）loop文も値を返す方法がある。

その方法は、**break の後ろに返り値を記述する方法**である。

```rust
// スコープ外の変数を操作したい場合は、スコープ外の変数を可変にしておく必要がある。
let mut y

// xに"100超"が格納される。
let x = loop {
	y += 1
	if y > 100 {
		break	"100超"
	}
}
```