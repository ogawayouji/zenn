# 第５章　データの所有権と借用

独特な仕組みと枠組み　コードをエラーになりにくくするもの？

## 「所有権」とは

### 束縛

以下の行為は、「変数に束縛する」と呼ぶ。

（宣言時の代入で、インスタンスを束縛することができる）

```rust
// fooへ構造体のインスタンスを束縛する行為
let foo = Foo { x: 100 };
```

※　束縛されるとメモリリソースが作成され、以降ライフタイムが終了するまでRustのコンパイラに確認され続ける。

→　確認される意味は？

### 所有権

インスタンスが束縛されている変数をリソースの**所有者**と呼び、所有し続ける権利を**所有権**と呼ぶ。

### なぜ所有権を考慮する必要があるか

Javaなどの言語では、参照されなくなったりして使用されなくなるインスタンスを**ガベージコレクション**という機能でメモリ上から削除する。

→　メモリの過剰な使用を防ぎ、メモリリークを起こさないようにする。

Rustでは、この**ガベージコレクション機能が存在しない**。

代わりにリソースの解放とメモリ上からの削除を行うための機能として、この**所有権**を利用する。

流れとしては以下。

1. 変数に束縛され、コンパイラによる監視が始まる
2. （スコープ内での変数の使用など、ここではコンパイラは**監視のみ**実施）

    所有権が生きている間は使われなくなっても解放されることがない。

3. スコープの終わりで、リソースの解放とメモリ上からの削除（**ドロップ**）を実施
4. 監視を終了

### 階層的なドロップ

ドロップ対象が階層的な構造をしているとき、ドロップは親飲みに実施される

→　順番に解放されていき、一回のみで完結する。

```rust
// 解放される時は、foo -> foo.bar の順番

let foo = Foo { bar: Bar { k: 100 } }
```

## 所有権の移動と回収

### move（移動）

所有権を別の変数に譲渡する行為。

所有権を移動すると、元のスコープでは所有権を所持せず、**変数を使用できなくなる**。

主に関数の実引数として渡す時はmoveに該当する

### 所有権を返す

移動した所有権を関数から返すことも可能。

所有権を返す行為は、関数の返り値を束縛することで達成できる。

### 所有権の借用（参照）

所有権は譲渡する方法以外に、元の変数から借り入れる（**元の変数にも所有権が残る**）方法がある。

<aside>
💡 借用（参照）には、演算子「&」を使う。

</aside>

```rust
let foo = Foo {x: 100 };
let bar = &foo;

// 借用の場合、それぞれの変数がドロップされる。借用元のみがドロップされる訳ではない。
```

借用は連鎖的に実施することも可能であり、借用した変数の一部を借用することなども可能。

下記に記載する借用ルールが守られていれば、連鎖的な借用の制限はない。

### 所有権の可変な借用

借用するとき、対象の変数を変更可能な状態で受け取ることができる。

この時、同一インスタンスへの2つ以上の箇所からの変更が可能になる可能性がある。

これはデータ競合を引き起こす可能性があるため、**Rustでは禁止されている**行為である。

データ競合防止のため、可変な借用が行われている間、借用元の変数の**移動および変更**ができなくなる。

→　借用先の変数のドロップを待つか、下記の返却を待つ必要がある。

<aside>
💡 可変な借用は、「&mut」演算子を使う。

</aside>

```rust
let mut foo = Foo { x: 100 };
let bar = &mut foo;

// この間で、fooの関数への引数渡しや、変更は禁止されている。以下の行為はコンパイルエラーになる。
// foo.x = 10;

bar.x = 200;
// barがここでドロップされるため、以降はfooへの変更および移動が可能になる。

foo.x = 10;
```

### 参照外し

可変な借用などで、元の変数への変更や移動ができなくなる。

変更や移動を行うためには可変先の借用のドロップを待つしかないが、これでは時間がかかりすぎたり、途中で変更したい場合など困る可能性がある。

Rustでは参照を外す（借用取りやめ）の方法がある。

<aside>
💡 参照外しは、「*」演算子を使う。

</aside>

```rust
let mut foo = 100;
let bar = &mut f;
// 参照外しした変数
let baz = *bar;

// fooへの直接的な変更は不可能
// foo.x = 10;

// 代わりに参照外しした変数への変更を行う
baz.x = 10;

// 100　10が印字される
println!("{} {}",bar, baz);
```

### 借用に関するルール

- 単一の変数に対して、可変な参照が1つだけある状態か、不変な参照が複数ある状態かのいずれかの状態しか達成できない。**両方存在することはできない**。

    →　データ競合防止のためのルール。

- 参照は、**参照元の所有者より長く**存在してはならない。

    →　存在しないデータへの参照がある、という矛盾した状態を防ぐためのルール。


## 明示的ライフタイム

変数の生存期間（ライフタイム）は、基本的にはコンパイラが管理し、常にメモリを整理してくれる。

ライフタイムをコンパイラに任せ切るのではなく、自分たちで管理する方法も存在する。

### ライフタイムの共有

「’」演算子で指定可能。

```rust
// 引数と返り値のライフタイムを共有する関数になる
fn sample_func<'a>(foo: &'a Foo) -> &'a i32 {
	&foo.x
}

fn main() {
	// fooとｙは同じタイミングでドロップされる
	let mut foo = Foo { x: 100 };
	let y = sample_func(&foo);
}
```

→　複雑なライフタイム管理に便利

### スタティックライフタイム

スタティック変数はプログラムの終了まで保持し続ける（ライフタイムが続く）変数である。

スタティックライフタイムは、**スタティック変数と同じライフタイム**という意味で、リソースに付与することが可能。

「’static」演算子で指定可能で、**決してドロップされることがない**。

→　スタティックライフタイムを使用する場合、参照を含む場合はその参照もスタティックライフタイムでなければならない。

（借用に関するルールの二番目のルールを満たすため？）

<aside>
💡 安全な処理を保証できない処理のための unsafe() メソッドがあるが、あまり推奨されない…

</aside>

## データ型のライフタイム

データ型のメンバにもライフタイムを指定することが可能。

→　ライフタイムを指定したメンバを持つ構造体が、**メンバが参照した参照元よりも長くは存在しない**ことを示す。

→　基本的に構造体のライフタイムは、メンバと親は共有する。

```rust
struct Foo<'a> {
	i: &'a i32,
}

fn main() {
	let x = 100;
	let foo = Foo {
		i : &x
	}
	// fooはｘより長く存在することはない。
}
```