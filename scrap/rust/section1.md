## 言語特徴

型推論型の言語である。

→　わざわざ定義する必要がない

→　コンパイル時に型を違反している構文がないかをコンパイラが確認してくれる

変数の可変と不変を大変気にする言語である。

→　後ほど追求する予定。

```rust
let mut a = 44
```

「mut」が可変属性を付与する。

（日頃からTypescriptをよく使うので、letの後ろに何かをつける文法は少し慣れない…）

→　文字列で試してみたら、警告文が出た。

![スクリーンショット 2024-04-15 23.47.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a2b7e29b-4b3b-4fb4-ad30-cce899433423/2bb313a8-a9c1-483f-bb66-8ca24b55f341/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88_2024-04-15_23.47.07.png)

文字列はすでに可変であると言うこと？

文字列の章があるので、先延ばし。

## 型

符号なし（u8など）と符号あり（i64など）の型がある。

→　メモリを気にするシステムに近い言語の特徴、C言語に近い？

スライス型について

コンパイラが決定して把握するコレクション型

→　コンパイルまでするまでわからない　→　**コンパイルするまでは長さが無限の配列**

文字列型について

文字列型はスライス型の延長にある型になっている。

実行時に、その文字列やスライスの長さが決定する。

→　文字列型は構成する文字に関するスライス型であると考える

```rust
13i32
```

上のように、数字の後ろに型を続けて記述できる。（知らなかったら混乱しそう）

タプル型について、要素番号をピリオドで繋ぐ書き方をする。（こちらも中々みたことがない）

```rust
tupple.0
```

## 配列

定義時に、型と配列の長さを同時に渡す。（独特かも）

```rust
let numbers: [u32; 4] = [0, 1, 2, 3];
```

なお、スライス型は　「; 4」の部分が必要ない。

## 関数

タプル型（（）で囲んだ型）を使うことで、複数の値を返すことができる。

**unit**：空のタプル　＝　（）

┗　あまり使われないらしい…