# Tour of Rust ６章　文字列

## 文字リテラル

値としての文字を一般に「文字リテラル」という。

文字リテラルの型は「&’static str」である。

つまり、**メモリ上の場所を参照**しており、ライフサイクルは**プログラム終了まで**を示す。

また、&mut**でない**ため、**変更が許可されない**。

<aside>
💡 str は常に有効なUTF-8形式の文字であることを示す。（UTF-8は１〜４バイトの可変長）

</aside>

### 特徴的なメソッド

- include_str!

ローカルファイルのテキストを変数に落とし込むメソッド。

```rust
let long_str = include_str!("sample.txt");
```

## String

**ヒープ領域に文字列を持つ構造体**。

→　文字リテラルと異なり、**拡張や変更が可能**である。

### メソッド

- push_str

文字列の最後に文字を追加する。

- replace

文字（UTF-8バイト）を別の文字で置換する。

- to_lowercase

文字を全て小文字に変換する。

- to_uppercase

文字を全て大文字に変換する。

- trim

空白を切り取る。

## 文字スライス

常に有効なUTF-８への**参照**のこと。（所有権そのものは渡されない）

部分的に切り出すことが可能。

```rust
let sample = "sample string";

let word1 = &sample[0..3];
let word2 = &sample[5..7];
```

### 関数の引数としても文字列

文字リテラルまたは文字列を関数の引数として渡すとき、**文字列スライス**として渡される。

→　所有権が渡らないので、柔軟性が向上

### メソッド

- len

文字列リテラルの長さを取得するメソッド。

- starts_with

最初の文字を検定するメソッド。

- ends_with

最後の文字を検定するメソッド。

- is_empty

文字列の長さが０かを検定するメソッド。

- find

検索対象が文字リテラルに含まれているかを検定するメソッド。

あれば数字を、なければNoneを返す。

```rust

    let a = "hello, world!";
    let find_word = a.find('h');

    match find_word {
        Some(i) => println!("{}", i),
        None => println!("None"),
    }
    // 0
```

- concat、join

文字列を連結させる。

文字列の配列に用いられる。

```rust
// hello world!
let sample = ["hello", " ", "world", "!"].concat();
```

- 文字列変換（to_string）

文字列以外の型を文字列にするメソッド。

失敗の可能性があるので、Resultで返ってくる。

- parse

文字列や文字リテラルを型付きの値に変更できるメソッド。

## Char

常に４バイトで長さを固定されている型。１文字が入る。

（４バイト固定は、Rustでの探索の利便性のため。）